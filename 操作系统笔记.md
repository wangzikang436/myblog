# 操作系统笔记

## 系统调用

根据进程访问资源的特点，可以把进程在系统上分为两个级别：

1. 用户态（user mode）: 用户态运行的进程可以直接读取用户程序的数据

2. 系统态（kernel mode）：系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。



凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成

系统调用按功能分类：

- 设备管理。完成设备的请求或释放，以及设备启动等功能
- 文件管理。完成文件的读、写、创建及删除等功能
- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能
- 进程通信。完成进程之间的消息传递或信号传递等功能
- 内存管理。完成内存的分配、回收及获取作业占用内存区大小及地址等功能



## 进程&线程

### 进程和线程的区别

进程（Process）是操作系统中一个正在执行中的程序实例。每个进程都有自己的地址空间、内存、堆栈和数据段等资源，同时也有自己的执行状态、程序计数器和打开文件等信息。每个进程都是由操作系统进行调度和管理的，进程之间相互独立，互不影响。

线程（Thread）是进程中的一个执行单元，一个进程可以包含多个线程。线程共享同一个进程的地址空间和资源，但是每个线程有自己的执行状态、程序计数器和栈等信息。线程之间可以共享数据，也可以通过锁等机制来保证数据的同步和互斥访问。线程的创建、切换和销毁等操作比进程要快，线程的开销也比进程小。

总结来说，进程和线程的主要区别有：

1. 资源管理：进程拥有独立的资源，线程共享进程的资源。
2. 调度单位：进程是操作系统分配资源和调度的基本单位，线程是调度的基本单位。
3. 执行状态：进程之间相互独立，互不影响；线程之间可以共享数据和资源，但也存在竞争和同步的问题。
4. 创建、切换和销毁：进程的创建、切换和销毁都比线程要慢和耗费资源。
5. 可并发性：线程的开销小，能够更好地利用 CPU 的多核特性，提高并发能力。

在编程中，使用多线程可以提高程序的并发性，提高程序的性能，但也需要注意线程安全和同步问题；使用多进程可以实现更大程度的并发性和资源隔离，但也需要注意进程间的通信和同步问题。

### *进程其中的一个线程异常终止,会导致整个进程崩溃吗

如果一个进程中的某个线程异常终止了，不一定会导致整个进程崩溃。这取决于进程的设计和实现方式以及异常的类型和处理方式等因素。

在一些操作系统中，例如 Windows，如果一个线程崩溃了而没有被捕获和处理，整个进程会崩溃，并会弹出相关的提示框。但是在其他操作系统中，例如 Linux，一个线程崩溃了不一定会导致整个进程崩溃，而是由该线程所在的进程决定如何处理异常。

在编写多线程程序时，为了避免某个线程崩溃导致整个进程崩溃，可以通过异常处理、信号处理等机制来捕获和处理异常，避免异常继续扩散和影响其他线程的正常执行。同时，也需要保证多线程程序的线程安全性，避免线程之间的竞争和冲突。

### 进程有哪几种状态?

- **创建状态****(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态****(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态****(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态****(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态****(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

### 进程间的通信方式

- **管道****/****匿名管道****(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
- **有名管道****(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出****(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
- **信号****(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
- **消息队列****(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。**消息队列克服了信号承载信息量少，管道只能承载无格式字** **节流以及缓冲区大小受限等缺点。**
- **信号量****(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。
- **共享内存****(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
- **套接字****(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。



### 线程间的同步方式

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

- **互斥量****(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
- **信号量****(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- **事件****(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 进程的调度算法

基本的操作系统进程调度算法包括先来先服务（first come first serve），时间片轮转（round robin），多级反馈轮转法（round robin with multiple feedback），优先级法（静态优先级法/动态优先级法），短作业优先法（shortest job first），最高响应比优先法（highest response_ratio next）。

- 先来先服务

先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。

来看一个例子，假设有三个进程和它们各自执行时间（以毫秒为单位）如下表：

![1348147106_5559](/Users/wangzikang/Downloads/1348147106_5559.png)

那么如果三个进程按照P1, P2, P3的顺序启动的话，按照先到先服务的调度算法，执行过程如下：

![1348147123_9218](/Users/wangzikang/Downloads/1348147123_9218.png)

平均等待时间就是(0 + 24 + 27) / 3 = 17毫秒。FCFS算法是非抢占式的，一旦内核将CPU分配给一个进程就不会被释放了，除非进程结束或者请求I/O阻塞。这也是我们之前学习的多任务系统的特点。

- 轮转法

这是一种基于时钟的抢占策略，以一个周期性间隔产生时钟中断，当中断发生时，当前正在运行的进程被置于就绪队列中，然后基于FCFS策略选择下一个就绪作业的运行。这种技术也称时间片，因为每个进程在被抢占前都给定一片时间。

来看下面的例子，假设一个时间片的长度为4毫秒：

![1348147281_3282](/Users/wangzikang/Downloads/1348147281_3282.png)

![1348147300_5996](/Users/wangzikang/Downloads/1348147300_5996.png)

- 最短进程

该算法从就绪队列中选出下一个“CPU执行期最短”的进程，为之分配处理机。
最短作业优先调度是优先级调度的特例。在优先级调度中我们根据进程的优先级来进行调度，在最短作业优先调度中我们
根据作业的执行时间长短来调度。
通过下面的例子来看看SJF是怎样调度的

![1348147220_7860](/Users/wangzikang/Downloads/1348147220_7860.png)

![1348147234_1048](/Users/wangzikang/Downloads/1348147234_1048.png)

进程1首先执行了1毫秒，当执行时间更短的进程2进入Ready队列时发生抢占。进程3在进程2执行1毫秒后到来，但是进程3的
执行时间比进程2长。同理进程4的到来也没法抢占进程2，所以进程2可以一直执行到结束。之后是执行时间第二短的进程4
执行，最后是进程1（要看剩余执行时间，还剩7毫秒）和进程3。

　　SJF调度是最优的调度，但难点在于如何预测进程的执行时间(Burst Time)。对于批处理系统中的长期调度来说，可以将用户
提交进程时输入的执行时间上限作为依据。但对于短期调度来说，没有办法能够提前得知下一个要被分配CPU的进程的执行
时间长短。

- 最短剩余时间

最短剩余时间（Shortest Remaining Time,SRT）是针对SPN增加了抢占机制的版本。在这种情况下，调度程序总是选择预期剩余时间最短的进程。当一个进程加入就绪队列时，它可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就可能抢占当前正在运行的进程。像SPN一样，调度程序在执行选择函数时必须有关于处理时间的估计，并且存在长进程饥饿的危险。

- 优先权调度算法

  1. 优先权调度算法的类型。为了照顾紧迫性作业，使之进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。 此算法常被用在批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度，还可以用于实时系统中。当其用于作业调度， 将后备队列中若干个优先权最高的作业装入内存。当其用于进程调度时，把处理机分配给就绪队列中优先权最高的进程，此时， 又可以进一步把该算法分成以下两种：
      1)非抢占式优先权算法
      2)抢占式优先权调度算法（高性能计算机操作系统）

  2. 优先权类型 。对于最高优先权优先调度算法，其核心在于：它是使用静态优先权还是动态优先权， 以及如何确定进程的优先权。 

  3. 高响应比优先调度算法 

    为了弥补短作业优先算法的不足，我们引入动态优先权，使作业的优先等级随着等待时间的增加而以速率a提高。 该优先权变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间；即 =（响应时间）/要求服务时间

![1348147165_7418](/Users/wangzikang/Downloads/1348147165_7418.png)

![1348147192_1775](/Users/wangzikang/Downloads/1348147192_1775.png)

`采取基于优先级调度算法要考虑进程饿死的问题，因为高优先级的进程总是会被优先调度，具有低优先级的进程可能永远`
`都不会被内核调度执行。Aging是对于这个问题的一个解决方案，所谓Aging就是指逐渐提高系统中长时间等待的进程的`
`优先级。比如如果优先级的范围从127到0（127表示最低优先级），那么我们可以每15分钟将等待进程的优先级加1。最终`
`经过一段时间，即便是拥有最低优先级127的进程也会变成系统中最高优先级的进程，从而被执行。`
    `优先级调度可以抢占式或者非抢占式的。当一个进程在Ready队列中时，内核将它的优先级与正在CPU上执行的进程的优先级`
`进行比较。当发现这个新进程的优先级比正在执行的进程高时：对于抢占式内核，新进程会抢占CPU，之前正在执行的进程`
`转入Ready队列；对于非抢占式内核，新进程只会被放置在Ready队列的头部，不会抢占正在执行的进程。`

- 多级反馈队列调度算法

多级反馈队列调度算法，不必事先知道各种进程所需要执行的时间，它是目前被公认的一种较好的进程调度算法。 其实施过程如下：
    1) 设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中， 为每个进程所规定的执行时间片就越小。
    2) 当一个新进程进入内存后，首先放入第一队列的末尾，按FCFS原则排队等候调度。 如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，在同样等待调度…… 如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。
    3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1到第（i-1）队列空时， 才会调度第i队列中的进程运行，并执行相应的时间片轮转。
    4) 如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列， 则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。

如果没有关于各进程相对长度的任何信息，则SPN，SRT和HRRN都不能使用。另一种导致偏向短作业的方法是处罚运行时间较长的作业，换句话说，如果不能获得剩余的执行时间，那就关注已经执行了的时间。

  方法为：调度基于抢占原则（按时间片）并且使用动态优先级机制。当一个进程第一次进入系统中时，它被放置在一个优先级队列中，当第一次被抢占后并返回就绪状态时，它被放置在下一个低优先级队列中，在随后的时间里，每当被抢占时，它被降级到下一个低优先级队列中。一个短进程很快会执行完，不会在就绪队列中降很多级，一个长进程会逐渐降级。因此新到的进程和短进程优先于老进程和长进程。在每个队列中，除了在优先级最低的队列中之外，都是用简单的FCFS机制，一旦一个进程处于优先级最低的队列中，它就不可能再降级，但会重复的返回该队列，知道运行结束。因此，该队列可按照轮转方式调度。

- 抢占式调度算法
  1. 非抢占式调度算法
  为每一个被控对象建立一个实时任务并将它们排列成一轮转队列,调度程序每次选择队列中的第一个任务投入运行.该任务完成后便把它挂在轮转队列的队尾等待下次调度运行.
  1. 非抢占式优先调度算法.
  实时任务到达时,把他们安排在就绪队列的对首,等待当前任务自我终止或运行完成后才能被调度执行.
  3. 抢占式调度算法
    1）基于时钟中断的抢占式优先权调度算法.
    实时任务到达后,如果该任务的优先级别高于当前任务的优先级并不立即抢占当前任务的处理机,而是等到时钟中断到来时,调度程序才剥夺当前任务的执行,将处理机分配给新到的高优先权任务.
    2）立即抢占的优先权调度算法.
    在这种调度策略中,要求操作系统具有快速响应外部时间中断的能力.一旦出现外部中断,只要当前任务未处于临界区便立即剥夺当前任务的执行,把处理机分配给请求中断的紧迫任务，实时进程调度，实时进程抢占当前

### 死锁

死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。

如果系统中以下四个条件同时成立，那么就能引起死锁：

- **互斥**：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。
- **占有并等待**：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。
- **非抢占**：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。
- **循环等待**：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，......，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。

[^注意]:只有四个条件同时成立时，死锁才会出现

#### 解决死锁的方法:

- **预防** 是采用某种策略，**限制并发进程对资源的请求**，从而使得死锁的必要条件在系统执行的任何时间上都不满足。
- **避免**则是系统在分配资源时，根据资源的使用情况**提前做出预测**，从而**避免死锁的发生**
- **检测**是指系统设有**专门的机构**，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。
- **解除** 是与检测相配套的一种措施，用于**将进程从死锁状态下解脱出来**。

#### **死锁的预防**

死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。

破坏第一个条件 **互斥条件**：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 **往往是不能同时访问的** ，所以这种做法在大多数的场合是行不通的。

破坏第三个条件 **非抢占** ：也就是说可以采用 **剥夺式调度算法**，但剥夺式调度方法目前一般仅适用于 **主存资源** 和 **处理器资源** 的分配，并不适用于所以的资源，会导致 **资源利用率下降**。

所以一般比较实用的 **预防死锁的方法**，是通过考虑破坏第二个条件和第四个条件。

1、静态分配策略

静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。

静态分配策略逻辑简单，实现也很容易，但这种策略 **严重地降低了资源利用率**，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 **几乎不用的资源而使其他需要该资源的进程产生等待** 的情况。

2、层次分配策略

层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略

#### 死锁检测步骤

知道了死锁检测的原理，我们可以利用下列步骤编写一个 **死锁检测** 程序，检测系统是否产生了死锁。

- 如果进程-资源分配图中无环路，则此时系统没有发生死锁
- 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。
- 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 **既不阻塞又非独立的进程** ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 **消除所有的边** ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 **拓扑排序**)

#### 死锁的解除

当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：

- **立即结束所有进程的执行，重新启动操作系统** ：这种方法简单，但以前所在的工作全部作废，损失很大。
- **撤销涉及死锁的所有进程，解除死锁后继续运行** ：这种方法能彻底打破**死锁的循环等待**条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。
- 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。
- **抢占资源** ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。